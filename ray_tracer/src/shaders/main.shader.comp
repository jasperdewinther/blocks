#version 430

float PI = 3.1415926538;

struct Uniforms{
    vec3 position;
    float time;
    vec3 direction;
};


layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(set=0, binding=1) uniform camera_details{
    Uniforms uni;
};

struct Circle{
    vec3 position;
    float radius;
    vec3 color;
};

Circle circles[4] = Circle[](Circle(vec3(3.0,1.0,8.0), 1.0, vec3(1.0,0.0,1.0)),
                             Circle(vec3(0.0,0.0,-6.0), 2.0, vec3(0.0,0.0,1.0)),
                             Circle(vec3(7.0,-2.0,0.0), 1.8, vec3(1.0,1.0,1.0)),
                             Circle(vec3(-7.0,-2.0,0.0), 1.5, vec3(0.0,1.0,0.0)));

vec3 rotation_x(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);

    mat3 matrix = mat3(
        1.0, 0.0, 0.0,
        0.0, c, s,
        0.0, -s, c
    );
    return matrix*v;
}
vec3 rotation_y(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, 0.0, -s,
        0.0, 1.0, 0.0,
        s, 0.0, c
    );
    return matrix*v;
}

float distance_to_circle(Circle circle, vec3 position){
    vec3 diff = abs(rotation_y(circle.position, uni.time/2.0) - position);
    float distance = sqrt(pow(diff[0],2) + pow(diff[1],2) + pow(diff[2],2));
    return max(distance-circle.radius, 0.0);
}

struct SdfReturn{
    float distance;
    int relevantCircleIndex;
};

SdfReturn sdf(vec3 position){
    float[4] distances = {0,0,0,0};
    for(int j = 0; j< circles.length(); j++){
        distances[j] = distance_to_circle(circles[j], position);
    }
    int closest = 0;
    float distance = 1000000;
    for (int i = 0; i < distances.length(); i++){
        if (distances[i] < distance){
            distance = distances[i];
            closest = i;
        }
    }
    return SdfReturn(distance, closest);
}



void main() {
    // base pixel colour for image
    vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
    // get index in global work group i.e x,y position
    ivec2 pixel_coordsi = ivec2(gl_GlobalInvocationID.xy);
    vec2 pixel_coords = vec2(pixel_coordsi);
    vec2 total_pixels = vec2(gl_NumWorkGroups.xy);
    //vec2 centre = total_pixels/2;
    //float anglex = (pixel_coords[0] - centre[0])/centre[0];
    //float angley = (pixel_coords[1] - centre[1])/centre[1];


    //pixel[0] = clamp(anglex/2.0+1.0, 0.0, 1.0);
    //pixel[1] = clamp(angley/2.0+1.0, 0.0, 1.0);
    //vec3 direction = normalize(vec3(anglex, angley, 1));
    float fov = 60;

    float imageAspectRatio = total_pixels[0] / total_pixels[1]; // assuming width > height
    float Px = (2 * ((pixel_coords[0] + 0.5) / total_pixels[0]) - 1) * tan(fov / 2 * PI / 180) * imageAspectRatio;
    float Py = (1 - 2 * ((pixel_coords[1] + 0.5) / total_pixels[1])) * tan(fov / 2 * PI / 180);
    vec3 rayOrigin = uni.position;
    vec3 direction = vec3(Px, Py, -1); // note that this just equal to Vec3f(Px, Py, -1);
    direction = normalize(direction);

    //vec3 direction = rotation_y(rotation_x(vec3(0.0,0.0,1.0), angle[1]), angle[0]);
    //vec3 direction = normalize(vec3(sin(), sin(), -1));
    //pixel = vec4(direction[0],direction[1],0.0, 1.0);
    int bounce = 0;


    for(int i = 1; i < 50; i++){
        SdfReturn sdf_result = sdf(rayOrigin);
        if (sdf_result.distance < 0.01){
            pixel = vec4(circles[sdf_result.relevantCircleIndex].color,1.0);
            if (bounce ==1){
                break;
            }
            bounce+=1;
            direction = reflect(direction, normalize(rayOrigin - circles[sdf_result.relevantCircleIndex].position));
            rayOrigin = rayOrigin+sdf_result.distance*direction*100;
        } else {
            rayOrigin = rayOrigin+sdf_result.distance*direction;
        }
        if (sdf_result.distance > 100){
            break;
        }
    }



    /*float sin_pixel_height = int(sin(uni.time*2 + pixel_coords[0]/(float(total_pixels[0])/PI/2))*total_pixels[1]/2) + total_pixels[1]/2;

    float sin_pixel_height_2 = int(sin(uni.time*2 + pixel_coords[0]/(float(total_pixels[0])/PI))*total_pixels[1]/2) + total_pixels[1]/2;

    float sin_pixel_height_3 = int(cos(uni.time*2 + pixel_coords[0]/(float(total_pixels[0])/PI/4))*total_pixels[1]/2) + total_pixels[1]/2;

    pixel[0] = abs(sin_pixel_height - pixel_coords[1])/float(total_pixels[1]);
    pixel[1] = abs(sin_pixel_height_2 - pixel_coords[1])/float(total_pixels[1]);
    pixel[2] = abs(sin_pixel_height_3 - pixel_coords[1])/float(total_pixels[1]);*/

    // output to a specific pixel in the image
    imageStore(img_output, pixel_coordsi, pixel);
}
