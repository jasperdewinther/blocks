#version 440

float PI = 3.1415926538;

struct Uniforms{
    vec3 position;
    float time;
    vec3 direction;
    vec3 sun_dir;
    uint brickmap_size;
    uint brick_size;
    vec3[3] ray_cast_data;
    vec4[16] colors;
};

layout(rgba8ui, binding = 0) uniform uimage2D img_output;
layout(binding = 1) readonly buffer brickmaps{
    uint[] brick_index;
};
layout(binding = 2) readonly buffer bricks{
    uint[] encoded_voxels;
};
layout(binding=3) uniform camera_details{
    Uniforms uni;
};

vec3 rotation_x(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);

    mat3 matrix = mat3(
        1.0, 0.0, 0.0,
        0.0, c, s,
        0.0, -s, c
    );
    return matrix*v;
}
vec3 rotation_y(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, 0.0, -s,
        0.0, 1.0, 0.0,
        s, 0.0, c
    );
    return matrix*v;
}
vec3 rotation_z(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, -s, 0.0,
        s, c, 0.0,
        0.0, 0.0, 1.0
    );
    return matrix*v;
}

vec3 generateRayDirection(){
    vec2 pixel_coords = gl_GlobalInvocationID.xy; //real pixel location
    float fov = 60;
    vec3 pij = uni.ray_cast_data[2]+uni.ray_cast_data[0]*(pixel_coords[0]-1) + uni.ray_cast_data[1]*(pixel_coords[1]-1);
    vec3 rij = normalize(pij);
    return rij;
}

uvec4 draw_sun(vec3 direction, uvec4 pixel){
    if (dot(direction, uni.sun_dir) < -0.99 ){
        return pixel + uvec4(pow(dot(direction, uni.sun_dir)*-1,1000) * vec4(255, 245, 127,255));
    }
    return pixel;
}

uvec4 draw_skyline(vec3 direction, uvec4 pixel){
    return uvec4(mix(vec3(200,200,200), vec3(51,102,204), direction[1]), 255);
}


const uint VoxelFilled = 0;
const uint VoxelEmpty = 1;
const uint VoxelOutOfBounds = 2;

uint isFilled(ivec3 location) {
    //validate indices
    //ivec3 which_brickmap = ivec3((location - uni.position)/(uni.brick_size * uni.brickmap_size))+1;
    //uint brickmap_offset = uint(which_brickmap[0] * pow(uni.brickmap_size, 3) + which_brickmap[1] * pow(uni.brickmap_size, 3) * 3 + which_brickmap[2] * pow(uni.brickmap_size, 3)*9);
    ivec3 which_brick = ivec3(mod((location - uni.position)/(uni.brick_size), uni.brickmap_size));
    uint brick_offset = uint(which_brick[0] + which_brick[1] * uni.brickmap_size + which_brick[2] * pow(uni.brickmap_size, 2));
    uint brick_i = brick_index[brick_offset];
    if (brick_i > pow(4,3)*27){
        return VoxelOutOfBounds;
    } else {
        ivec3 which_voxel = ivec3(mod((location - uni.position)/(uni.brick_size), uni.brickmap_size));
        uint voxel_index = uint(which_voxel[0] + which_voxel[1] * uni.brick_size + which_voxel[2] * pow(uni.brick_size, 2));
        uint voxel_data = encoded_voxels[brick_i/4];
        uint voxel = voxel_data >> uint(8 * (mod(brick_i,4)*-1+3));
        return voxel == 0? 1 : 0;
    }
}

//uvec4 get_voxel_color(ivec3 location){

//}



//https://www.researchgate.net/profile/Kai-Xiao-9/publication/233899848_Efficient_implementation_of_the_3D-DDA_ray_traversal_algorithm_on_GPU_and_its_application_in_radiation_dose_calculation/links/5acfaa9b4585154f3f47bf20/Efficient-implementation-of-the-3D-DDA-ray-traversal-algorithm-on-GPU-and-its-application-in-radiation-dose-calculation.pdf?origin=publication_detail
uvec4 trace_ray(vec3 direction, vec3 origin){
    vec3 current_voxel = origin;
    int iter = 0;


    vec3 step = abs(direction)/direction;
    vec3 invDir = 1/direction;
    vec3 T = vec3(bool(step[0]) ? mod(origin[0], 1) : 1-direction[0],bool(step[1]) ? mod(origin[1], 1) : 1-direction[1],bool(step[2]) ? mod(origin[2], 1) : 1-direction[2]);
    vec3 DeltaT = invDir;
    vec3 VoxelIncr = vec3(0);
    bool inside_map = true;
    while(iter < 50){
        VoxelIncr[0] = float((T[0]<=T[1]) && (T[0]<=T[2]));
        VoxelIncr[1] = float((T[1]<=T[0]) && (T[1]<=T[2]));
        VoxelIncr[2] = float((T[2]<=T[0]) && (T[2]<=T[1]));
        T = VoxelIncr * DeltaT;
        current_voxel += VoxelIncr*step;
        uint voxel = isFilled(ivec3(current_voxel));
        if (voxel == VoxelFilled){
            return uvec4(255,255,0,255);
        } else if (voxel == VoxelOutOfBounds){
            return uvec4(0,0,0,255);
        }
        iter+=1;
    }
    return uvec4(0,0,0,255);
}


void main() {
    vec3 origin = uni.position;
    vec3 direction = generateRayDirection();
    uvec4 pixel = trace_ray(direction, origin);
    if (pixel == vec4(0,0,0,255)){
        pixel = draw_skyline(direction, pixel);
        pixel = draw_sun(direction, pixel);
    }


    imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
    return;
}
