#version 440

float PI = 3.1415926538;

struct Uniforms{
    vec3 position;
    float time;
    vec3 direction;
    vec3 sun_dir;
    vec3[3] ray_cast_data;
    vec4[16] colors;
    vec3[27] brickmap_locations;
};

struct Circle{
    vec3 position;
    float radius;
    vec3 color;
};

struct SdfReturn{
    float distance;
    int relevantCircleIndex;
};

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba8ui, binding = 0) uniform uimage2D img_output;
layout(binding = 1) readonly buffer brickmaps{
    uint[] brick_index;
};
layout(binding = 2) readonly buffer bricks{
    uint[] encoded_voxels;
};
layout(binding=3) uniform camera_details{
    Uniforms uni;
};



Circle circles[4] = Circle[](Circle(vec3(0.0,0.0,3.0), 1.0, vec3(1.0,0.0,1.0)),
                             Circle(vec3(0.0,0.0,-3.0), 1.0, vec3(0.0,0.0,1.0)),
                             Circle(vec3(3.0,0.0,0.0), 1.0, vec3(1.0,1.0,1.0)),
                             Circle(vec3(-3.0,0.0,0.0), 1.0, vec3(0.0,1.0,0.0)));

vec3 rotation_x(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);

    mat3 matrix = mat3(
        1.0, 0.0, 0.0,
        0.0, c, s,
        0.0, -s, c
    );
    return matrix*v;
}
vec3 rotation_y(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, 0.0, -s,
        0.0, 1.0, 0.0,
        s, 0.0, c
    );
    return matrix*v;
}
vec3 rotation_z(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, -s, 0.0,
        s, c, 0.0,
        0.0, 0.0, 1.0
    );
    return matrix*v;
}

vec3 generateRayDirection(){
    vec2 pixel_coords = gl_GlobalInvocationID.xy; //real pixel location
    vec2 total_pixels = vec2(imageSize(img_output)); //total screen size

    float fov = 60;

    vec3 pij = uni.ray_cast_data[2]+uni.ray_cast_data[0]*(pixel_coords[0]-1) + uni.ray_cast_data[1]*(pixel_coords[1]-1);
    vec3 rij = normalize(pij);
    return rij;
}

uvec4 draw_sun(vec3 direction, uvec4 pixel){
    if (dot(direction, uni.sun_dir) < -0.99 ){
        return pixel + uvec4(pow(dot(direction, uni.sun_dir)*-1,1000) * vec4(255, 245, 127,255));
    }
    return pixel;
}

uvec4 draw_skyline(vec3 direction, uvec4 pixel){
    return uvec4(mix(vec3(200,200,200), vec3(51,102,204), direction[1]), 255);
}

void main() {
    vec3 origin = uni.position;
    vec3 direction = generateRayDirection();
    uvec4 pixel = uvec4(0,0,0,255);

    pixel = draw_skyline(direction, pixel);
    pixel = draw_sun(direction, pixel);


    imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
    return;
}
