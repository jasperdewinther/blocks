#version 440

float PI = 3.1415926538;

struct Uniforms{
    vec3 position;
    float time;
    vec3 direction;
    float _padding;
    vec3 sun_dir;
    vec4[16] colors;
};

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba8ui, binding = 0) uniform uimage2D img_output;
layout(binding=1) uniform camera_details{
    Uniforms uni;
};

struct Circle{
    vec3 position;
    float radius;
    vec3 color;
};

Circle circles[4] = Circle[](Circle(vec3(0.0,0.0,3.0), 1.0, vec3(1.0,0.0,1.0)),
                             Circle(vec3(0.0,0.0,-3.0), 1.0, vec3(0.0,0.0,1.0)),
                             Circle(vec3(3.0,0.0,0.0), 1.0, vec3(1.0,1.0,1.0)),
                             Circle(vec3(-3.0,0.0,0.0), 1.0, vec3(0.0,1.0,0.0)));

vec3 rotation_x(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);

    mat3 matrix = mat3(
        1.0, 0.0, 0.0,
        0.0, c, s,
        0.0, -s, c
    );
    return matrix*v;
}
vec3 rotation_y(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, 0.0, -s,
        0.0, 1.0, 0.0,
        s, 0.0, c
    );
    return matrix*v;
}

float distance_to_circle(Circle circle, vec3 position){
    vec3 diff = abs(circle.position - position);
    float distance = sqrt(pow(diff[0],2) + pow(diff[1],2) + pow(diff[2],2));
    return max(distance-circle.radius, 0.0);
}

struct SdfReturn{
    float distance;
    int relevantCircleIndex;
};

SdfReturn sdf(vec3 position){
    float[4] distances = {0,0,0,0};
    for(int j = 0; j< circles.length(); j++){
        distances[j] = distance_to_circle(circles[j], position);
    }
    int closest = 0;
    float distance = 1000000;
    for (int i = 0; i < distances.length(); i++){
        if (distances[i] < distance){
            distance = distances[i];
            closest = i;
        }
    }
    return SdfReturn(distance, closest);
}
struct RayCircleIntersects{
    bool intersects;
    vec3 position;
};

//https://stackoverflow.com/questions/6533856/ray-sphere-intersection
RayCircleIntersects ray_intersects_circle(Circle circle, vec3 origin, vec3 direction){
    vec3 second_point = origin + direction;
    float b = 2*dot(direction, origin-circle.position);
    vec3 origin_to_circle = origin-circle.position;
    float c = dot(origin_to_circle,origin_to_circle)-pow(circle.radius, 2.0);
    float delta = pow(b,2.0)-4*c;
    if (delta < 0){
        return RayCircleIntersects(false, vec3(0.0));
    }

    float d1 = (-b-sqrt(delta))/(2);
    float d2 = (-b+sqrt(delta))/(2);

    vec3 position = origin + min(d1,d2)*(direction-origin);



    return RayCircleIntersects(true, position);
}



void main() {
    vec2 pixel_coordsi = gl_GlobalInvocationID.xy; //real pixel location
    vec2 total_pixels = vec2(imageSize(img_output)); //total screen size
    uvec4 pixel = uvec4(0, 255.0*pixel_coordsi[0]/total_pixels[0], 255.0*pixel_coordsi[1]/total_pixels[1], 255);

    vec2 pixel_coords = vec2(pixel_coordsi);

    float fov = 90;

    float imageAspectRatio = total_pixels[0] / total_pixels[1]; // roughly 1.778 on normal resolution
    float Px = (2 * ((pixel_coords[0]) / total_pixels[0]) - 0.5) * tan(fov / 2 * PI / 180) * imageAspectRatio; // -1.778 to 1.778
    float Py = (2 * ((pixel_coords[1]) / total_pixels[1])-0.5) * tan(fov / 2 * PI / 180); // -1 to 1

    float direction_rotation_y = sin(uni.direction[1]);
    float direction_rotation_x = sin(uni.direction[0]);
    vec3 ray_direction_modifier = normalize(vec3(Px, 0, 0));


    vec3 rayOrigin = uni.position;
    vec3 direction = rotation_y(uni.direction, Px); // note that this just equal to Vec3f(Px, Py, -1);
    vec3 fpixel = vec3((1-direction[1])*vec3(200,200,200) + direction[1] * vec3(51,102,204));
    pixel = uvec4(uint(fpixel[0]),uint(fpixel[1]),uint(fpixel[2]),255);


    direction = normalize(rotation_y(direction, uni.time/2.0));
    if (dot(direction, uni.sun_dir) < -0.999 ){
        pixel = uvec4(dot(direction, uni.sun_dir)*-1 * vec4(255, 245, 127,255));
    }


    //vec3 direction = rotation_y(rotation_x(vec3(0.0,0.0,1.0), angle[1]), angle[0]);
    //vec3 direction = normalize(vec3(sin(), sin(), -1));
    //pixel = vec4(direction[0],direction[1],0.0, 1.0);
    int bounce = 0;


    float depth = 100000.0;
    for(int j = 0; j< circles.length(); j++){
        RayCircleIntersects r  = ray_intersects_circle(circles[j], rayOrigin, direction);
        vec3 ray_camera_diff = rayOrigin - r.position;



        float distance = dot(ray_camera_diff,ray_camera_diff);
        if (r.intersects && distance < depth){
            depth = distance;
            vec3 refracted_direction = reflect(direction, normalize(circles[j].position - r.position))*255;
            pixel = uvec4(0,0,(sqrt(distance)-60)*1.4285, 255);
        }
    }
    imageStore(img_output, ivec2(pixel_coordsi), pixel);
    return;

}
